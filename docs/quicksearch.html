<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"column.js.html":{"id":"column.js.html","title":"Source: column.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Source: column.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Group that places new child nodes directly under the previous child. * @constructor * @param {Object} game - Current game instance. * @param {Object }context - The context this object is called in. */ uiWidgets.Column = function (game, context) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.game = game; this.context = context; }; uiWidgets.Column.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Column.constructor = uiWidgets.Column; /** Adds a new object into the Column, then aligns it under the previous object. */ uiWidgets.Column.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); var previousNode = this.children[this.children.length - 2]; if (previousNode !== undefined) { node.alignTo(previousNode, Phaser.BOTTOM_CENTER); } }; × Search results Close "},"row.js.html":{"id":"row.js.html","title":"Source: row.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Source: row.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Group that places new child nodes directly next to the previous child. * @constructor * @param {Object} game - Current game instance. * @param {Object }context - The context this object is called in. */ uiWidgets.Row = function (game, context) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.game = game; this.context = context; }; uiWidgets.Row.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Row.constructor = uiWidgets.Row; /** Adds a new object into the Row, then aligns it next to the previous object. */ uiWidgets.Row.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); var previousNode = this.children[this.children.length - 2]; if (previousNode !== undefined) { node.alignTo(previousNode, Phaser.RIGHT_CENTER); } }; × Search results Close "},"scrollbar.js.html":{"id":"scrollbar.js.html","title":"Source: scrollbar.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Source: scrollbar.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Creates a bar that moves along a track. The bar is resized relative to the size of the track and size of the content to be scrolled. Content outside the viewport has input disabled. * @constructor * @param {Object} game - Current game instance. * @param {Object} content - Anything that you want to move via the scrollbar. * @param {boolean} draggable - Determines if the scrollbar responds to mouse clicks. * @param {boolean} vertical - Determines if the scrollbar should be vertical or horizontal. * @param {boolean} keyboard - Determines if the scrollbar responds to keyboard input. * @param {string} trackImage - The image key to use for the track. * @param {string} barImage - The image key to use for the bar. Will be automatically resized to fit. */ uiWidgets.Scrollbar = function (game, content, draggable, vertical, keyboard, trackImage, barImage) { &quot;use strict&quot;; this.game = game; this.content = content; this.vertical = vertical || false; this.draggable = draggable || false; keyboard = keyboard || false; if (keyboard) { this.enableKeyboard(); } this.trackImage = trackImage; this.barImage = barImage; // Padding between content and scrollbar. // TODO: Don't hard-code this value. var padding = 10; if (this.vertical) { this.x = this.content.x + this.content.width + padding; this.y = this.content.y; } else { this.x = this.content.x; this.y = this.content.y + this.content.height + padding; } // The smallest pixel size allowed for the bar. this.minBarSize = 44; // Animation this.tweenTiming = 300; this.tweenEasing = Phaser.Easing.Quadratic.Out; // Flag switched on when the track is clicked, switched off after the bar movement is finished. this.trackClicked = false; this.barMoving = false; // Records mouse pointer when clicking the bar. this.mousePointer = null; this.create(); }; uiWidgets.Scrollbar.prototype = { /** Enables keyboard input for the scrollbar */ enableKeyboard: function () { &quot;use strict&quot;; this.upKey = this.game.input.keyboard.addKey(Phaser.Keyboard.UP); this.downKey = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN); this.leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT); this.rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT); if (this.vertical) { this.upKey.onDown.add(this.scrollUp, this); this.downKey.onDown.add(this.scrollDown, this); this.leftKey.onDown.add(this.scrollUp, this); this.rightKey.onDown.add(this.scrollDown, this); } else { this.upKey.onDown.add(this.scrollLeft, this); this.downKey.onDown.add(this.scrollRight, this); this.leftKey.onDown.add(this.scrollLeft, this); this.rightKey.onDown.add(this.scrollRight, this); } }, /** Allows the bar to scroll when the track is clicked. */ enableTrackClick: function () { &quot;use strict&quot;; this.track.inputEnabled = true; this.track.events.onInputDown.add(this.clickTrack, this); }, create: function () { &quot;use strict&quot;; this.track = this.game.add.sprite(this.x, this.y, this.trackImage); // Clicking the track will move the bar up or down. if (this.draggable) { this.enableTrackClick(); } // Bar sprite. this.bar = this.game.add.button( this.track.x, this.track.y, this.barImage, this.moveContent, this, 1, 0 ); var verticalAttributes = { &quot;barDefaultX&quot;: this.track.x + (this.track.width / 2) - (this.bar.width / 2), &quot;barDefaultY&quot;: this.track.y, &quot;viewportSize&quot;: this.content.area.height, &quot;containerSize&quot;: this.content.height, &quot;barMaxSize&quot;: this.track.height }; var horizontalAttributes = { &quot;barDefaultX&quot;: this.track.x, &quot;barDefaultY&quot;: this.track.y + (this.track.height / 2) - (this.bar.height / 2), &quot;viewportSize&quot;: this.content.area.width, &quot;containerSize&quot;: this.content.width, &quot;barMaxSize&quot;: this.track.width }; var attributes; if (this.vertical) { attributes = verticalAttributes; } else { attributes = horizontalAttributes; } // Set default position for the bar. Center it on the non-moving axis inside the track. this.barDefaultX = attributes.barDefaultX; this.barDefaultY = attributes.barDefaultY; this.bar.x = this.barDefaultX; this.bar.y = this.barDefaultY; var windowContentRatio = attributes.viewportSize / attributes.containerSize; //-- Set Bar Size --// // Prevents bar from being larger than the track. if (windowContentRatio &gt; 1) { windowContentRatio = 1; } var barSize = attributes.barMaxSize * windowContentRatio; // Prevents bar from becoming microscopic. if (barSize &lt; this.minBarSize) { barSize = this.minBarSize; } // Resizes the bar. if (this.vertical) { this.bar.height = barSize; } else { this.bar.width = barSize; } //-- Enable mouse dragging --// if (this.draggable) { this.bar.inputEnabled = true; this.bar.input.enableDrag(); this.bar.events.onInputDown.add(this.saveMousePosition, this); this.bar.events.onDragUpdate.add(this.moveContent, this); // Limit the bar's draggable area to within the track. if (this.vertical) { this.bar.input.allowHorizontalDrag = false; this.bar.input.boundsRect = new Phaser.Rectangle( this.track.x, this.track.y, this.track.x, this.track.height ); } else { this.bar.input.allowVerticalDrag = false; this.bar.input.boundsRect = new Phaser.Rectangle( this.track.x, this.track.y, this.track.width, this.track.y ); } } // Determine the distance the window can scroll over this.windowScrollAreaSize = attributes.containerSize - attributes.viewportSize; // Determine the distance the bar can scroll over if (this.vertical) { this.trackScrollAreaSize = this.track.height - this.bar.height; } else { this.trackScrollAreaSize = this.track.width - this.bar.width; } }, resetPosition: function () { &quot;use strict&quot;; this.bar.x = this.barDefaultX; this.bar.y = this.barDefaultY; }, /** For Vertical Scrollbars. Scrolls the content up by one window. */ scrollUp: function () { &quot;use strict&quot;; // Prevents users from moving the bar while it's moving. if (this.bar.y !== this.track.y &amp;&amp; !this.barMoving) { var testPosition = this.bar.y - this.bar.height; var moveToY = null; this.barMoving = true; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.y) { moveToY = this.track.y; } else { moveToY = this.bar.y - this.bar.height; } var up = this.game.add.tween(this.bar).to( {y: moveToY}, this.tweenTiming, this.tweenEasing, true ); this.mousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; this.trackClicked = true; up.onUpdateCallback(this.moveContent, this); up.onComplete.add(this.enableBarInput, this); } }, /** For Vertical Scrollbars. Scrolls the content down by one window. */ scrollDown: function () { &quot;use strict&quot;; if (this.bar.y + this.bar.height !== this.track.y + this.track.height &amp;&amp; !this.barMoving) { var testPosition = this.bar.y + this.bar.height * 2; var moveToY = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.y + this.track.height) { moveToY = this.track.y + this.track.height - this.bar.height; } else { moveToY = this.bar.y + this.bar.height; } var down = this.game.add.tween(this.bar).to( {y: moveToY}, this.tweenTiming, this.tweenEasing, true ); this.mousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; this.trackClicked = true; down.onUpdateCallback(this.moveContent, this); down.onComplete.add(this.enableBarInput, this); } }, /** For Horizontal Scrollbars. Scrolls the content left by one window. */ scrollLeft: function () { &quot;use strict&quot;; if (this.bar.x !== this.track.x &amp;&amp; !this.barMoving) { var testPosition = this.bar.x - this.bar.width; var moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.x) { moveToX = this.track.x; } else { moveToX = this.bar.x - this.bar.width; } var left = this.game.add.tween(this.bar).to( {x: moveToX}, this.tweenTiming, this.tweenEasing, true ); this.mousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; this.trackClicked = true; left.onUpdateCallback(this.moveContent, this); left.onComplete.add(this.enableBarInput, this); } }, /** For Horizontal Scrollbars. Scrolls the content right by one window. */ scrollRight: function () { &quot;use strict&quot;; if (this.bar.x + this.bar.width !== this.track.x + this.track.width &amp;&amp; !this.barMoving) { var testPosition = this.bar.x + this.bar.width * 2; var moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.x + this.track.width) { moveToX = this.track.x + this.track.width - this.bar.width; } else { moveToX = this.bar.x + this.bar.width; } var right = this.game.add.tween(this.bar).to( {x: moveToX}, this.tweenTiming, this.tweenEasing, true ); this.mousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; this.trackClicked = true; right.onUpdateCallback(this.moveContent, this); right.onComplete.add(this.enableBarInput, this); } }, enableBarInput: function () { this.trackClicked = false; this.barMoving = false; this.bar.inputEnabled = true; }, /** If the scrollbar is draggable, this function is called when the track is clicked. */ clickTrack: function (sprite, pointer) { &quot;use strict&quot;; if (this.vertical) { // Don't register mouse clicks on the bar itself. if (this.game.input.mousePointer.y &gt; this.bar.y + this.bar.height) { this.scrollDown(); } else if (this.game.input.mousePointer.y &lt; this.bar.y + this.bar.height) { this.scrollUp(); } } else { // Don't register mouse clicks on the bar itself. if (this.game.input.mousePointer.x &gt; this.bar.x + this.bar.width) { this.scrollRight(); } else if (this.game.input.mousePointer.x &lt; this.bar.x + this.bar.width) { this.scrollLeft(); } } }, saveMousePosition: function (sprite, pointer) { &quot;use strict&quot;; // If the bar is draggable, record where the mouse clicked down. this.mousePointer = {&quot;x&quot;: pointer.x, &quot;y&quot;: pointer.y}; }, getBarPosition: function () { &quot;use strict&quot;; var currentArea; if (this.vertical) { // y - an offset for where the viewport is on screen. currentArea = this.content.y - this.content.area.y; } else { currentArea = this.content.x - this.content.area.x; } var windowPositionRatio = currentArea / this.windowScrollAreaSize; return this.trackScrollAreaSize * windowPositionRatio; }, /** This function is called when the mouse is clicked on the bar. Causes the content to move relative to the bar's position on the track. */ moveContent: function () { &quot;use strict&quot;; var gripPositionOnTrack = this.getBarPosition(); var oldMousePosition, newMousePosition, newMousePointer; if (this.vertical) { oldMousePosition = this.mousePointer.y; } else { oldMousePosition = this.mousePointer.x; } // Only difference between clicking the track/using the keyboard vs mouse drag. if (this.trackClicked) { newMousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; } else { newMousePointer = {&quot;x&quot;: this.game.input.mousePointer.x, &quot;y&quot;: this.game.input.mousePointer.y}; } if (this.vertical) { newMousePosition = newMousePointer.y; } else { newMousePosition = newMousePointer.x; } this.mousePointer = newMousePointer; // Only update when the new position is inside the track var maxValue; if (this.vertical) { maxValue = this.track.height; } else { maxValue = this.track.width; } var mousePositionDelta; if (newMousePosition &lt; maxValue) { mousePositionDelta = oldMousePosition - newMousePosition; } else { mousePositionDelta = 0; } var newGripPosition = gripPositionOnTrack + mousePositionDelta; // Don't let the content scroll above or below the track's size if (newGripPosition &gt; 0) { newGripPosition = 0; } else if (newGripPosition &lt;= -this.trackScrollAreaSize) { newGripPosition = -this.trackScrollAreaSize; } // When the scrollbar is at the top or bottom, prevent a mouse movement that // doesn't move the scrollbar from moving the content. if (this.vertical) { if (this.bar.y &lt;= this.track.y) { newGripPosition = 0; } else if (this.bar.y + this.bar.height &gt;= this.track.y + this.track.height) { newGripPosition = -this.trackScrollAreaSize; } } else { if (this.bar.x &lt;= this.track.x) { newGripPosition = 0; } else if (this.bar.x + this.bar.width &gt;= this.track.x + this.track.width) { newGripPosition = -this.trackScrollAreaSize; } } var newGripPositionRatio = newGripPosition / this.trackScrollAreaSize; // If the scrollable area is less than the size of the scrollbar, the bar and track will be the same size. // In this scenario, a divide by zero occurs. Capture that and turn it into zero. if (isNaN(newGripPositionRatio)) { newGripPositionRatio = 0; } var newContentPosition = newGripPositionRatio * this.windowScrollAreaSize; // Needs an offset for where the viewport is on screen. if (this.vertical) { this.content.y = newContentPosition + this.content.area.y; } else { this.content.x = newContentPosition + this.content.area.x; } disableOutOfBounds(this.content.children, this, this.vertical); } }; // Whenever the content is moved, disable input for all objets outside the viewport. var disableOutOfBounds = function (content, context, vertical) { &quot;use strict&quot;; // Makes sure the recursive function stops when there's no children. if (content !== undefined) { for (var i=0; i &lt; content.length; i++) { var child = content[i]; child.inputEnabled = true; // An object's x/y is relative to it's parent. // The world gives an x/y relative to the whole game. var trueCoords = child.world || child; var location, contentLocation; if (vertical) { location = trueCoords.y; contentLocation = context.content.area.y; } else { location = trueCoords.x; contentLocation = context.content.area.x; } if (location &lt; contentLocation) { child.inputEnabled = false; } disableOutOfBounds(child.children, context, vertical); } } }; × Search results Close "},"buttons.js.html":{"id":"buttons.js.html","title":"Source: buttons.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Source: buttons.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Sprite with text added as a child. * @constructor * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. */ uiWidgets.textSprite = function (game, image, label, style, x, y) { &quot;use strict&quot;; Phaser.Sprite.call(this, game, x, y, image); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); }; uiWidgets.textSprite.prototype = Object.create(Phaser.Sprite.prototype); uiWidgets.textSprite.constructor = uiWidgets.textSprite; /** * Phaser Button with text added as a child. * @constructor * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. * @param callback - Callback to use when the button is clicked. * @param callbackContext {Object} - The context the callback is called in. */ uiWidgets.textButton = function (game, image, label, style, x, y, callback, callbackContext) { &quot;use strict&quot;; Phaser.Button.call(this, game, x, y, image, callback, callbackContext); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); }; uiWidgets.textButton.prototype = Object.create(Phaser.Button.prototype); uiWidgets.textButton.constructor = uiWidgets.textButton; × Search results Close "},"viewport.js.html":{"id":"viewport.js.html","title":"Source: viewport.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Source: viewport.js var Phaser; var uiWidgets = uiWidgets || {}; /** * A container for other objects with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area. * @constructor * @param {Object} game - Current game instance. * @param {number} x - The x coordinate on screen where the viewport will be placed. * @param {number} y - The y coordinate on screen where the viewport will be placed. * @param width {number} - The width of the viewport. * @param height {number} - The height of the viewport. */ uiWidgets.Viewport = function (game, x, y, width, height) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.x = x; this.y = y; // Viewport size and position, distinct from the total window size. this.area = { &quot;x&quot;: x, &quot;y&quot;: y, &quot;width&quot;: width, &quot;height&quot;: height }; // Adding the mask attribute to a group hides objects outside the mask. this.mask = this.game.add.graphics(this.area.x, this.area.y); this.mask.beginFill(0x0000ff); this.mask.drawRect(0, 0, width, height); this.mask.endFill(); }; uiWidgets.Viewport.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Viewport.constructor = uiWidgets.Viewport; /** Adds a new object into the Viewport. */ uiWidgets.Viewport.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Classes Classes Column Row Scrollbar textButton textSprite Viewport × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport × Search results Close "},"uiWidgets.Column.html":{"id":"uiWidgets.Column.html","title":"Class: Column","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: Column Column new Column(game, context) Group that places new child nodes directly under the previous child. Parameters: Name Type Description game Object Current game instance. context Object The context this object is called in. Source: column.js, line 11 Methods addNode() Adds a new object into the Column, then aligns it under the previous object. Source: column.js, line 25 × Search results Close "},"uiWidgets.Row.html":{"id":"uiWidgets.Row.html","title":"Class: Row","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: Row Row new Row(game, context) Group that places new child nodes directly next to the previous child. Parameters: Name Type Description game Object Current game instance. context Object The context this object is called in. Source: row.js, line 11 Methods addNode() Adds a new object into the Row, then aligns it next to the previous object. Source: row.js, line 25 × Search results Close "},"uiWidgets.Scrollbar.html":{"id":"uiWidgets.Scrollbar.html","title":"Class: Scrollbar","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: Scrollbar Scrollbar new Scrollbar(game, content, draggable, vertical, keyboard, trackImage, barImage) Creates a bar that moves along a track. The bar is resized relative to the size of the track and size of the content to be scrolled. Content outside the viewport has input disabled. Parameters: Name Type Description game Object Current game instance. content Object Anything that you want to move via the scrollbar. draggable boolean Determines if the scrollbar responds to mouse clicks. vertical boolean Determines if the scrollbar should be vertical or horizontal. keyboard boolean Determines if the scrollbar responds to keyboard input. trackImage string The image key to use for the track. barImage string The image key to use for the bar. Will be automatically resized to fit. Source: scrollbar.js, line 17 Methods clickTrack() If the scrollbar is draggable, this function is called when the track is clicked. Source: scrollbar.js, line 335 enableKeyboard() Enables keyboard input for the scrollbar Source: scrollbar.js, line 64 enableTrackClick() Allows the bar to scroll when the track is clicked. Source: scrollbar.js, line 86 moveContent() This function is called when the mouse is clicked on the bar. Causes the content to move relative to the bar's position on the track. Source: scrollbar.js, line 376 scrollDown() For Vertical Scrollbars. Scrolls the content down by one window. Source: scrollbar.js, line 240 scrollLeft() For Horizontal Scrollbars. Scrolls the content left by one window. Source: scrollbar.js, line 269 scrollRight() For Horizontal Scrollbars. Scrolls the content right by one window. Source: scrollbar.js, line 299 scrollUp() For Vertical Scrollbars. Scrolls the content up by one window. Source: scrollbar.js, line 210 × Search results Close "},"uiWidgets.textButton.html":{"id":"uiWidgets.textButton.html","title":"Class: textButton","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: textButton textButton new textButton(game, image, label, style, x, y, callback, callbackContext) Phaser Button with text added as a child. Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. callback Callback to use when the button is clicked. callbackContext Object The context the callback is called in. Source: buttons.js, line 43 × Search results Close "},"uiWidgets.textSprite.html":{"id":"uiWidgets.textSprite.html","title":"Class: textSprite","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: textSprite textSprite new textSprite(game, image, label, style, x, y) Sprite with text added as a child. Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. Source: buttons.js, line 16 × Search results Close "},"uiWidgets.Viewport.html":{"id":"uiWidgets.Viewport.html","title":"Class: Viewport","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.Viewport Class: Viewport Viewport new Viewport(game, x, y, width, height) A container for other objects with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area. Parameters: Name Type Description game Object Current game instance. x number The x coordinate on screen where the viewport will be placed. y number The y coordinate on screen where the viewport will be placed. width number The width of the viewport. height number The height of the viewport. Source: viewport.js, line 15 Methods addNode() Adds a new object into the Viewport. Source: viewport.js, line 42 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
