<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"column.js.html":{"id":"column.js.html","title":"Source: column.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Source: column.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Group that places new child nodes directly under the previous child. * @constructor * @param {Object} game - Current game instance. * @param {Object }context - The context this object is called in. */ uiWidgets.Column = function (game, context) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.game = game; this.context = context; }; uiWidgets.Column.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Column.constructor = uiWidgets.Column; /** Adds a new object into the Column, then aligns it under the previous object. */ uiWidgets.Column.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); var previousNode = this.children[this.children.length - 2]; if (previousNode !== undefined) { node.alignTo(previousNode, Phaser.BOTTOM_CENTER); } }; × Search results Close "},"row.js.html":{"id":"row.js.html","title":"Source: row.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Source: row.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Group that places new child nodes directly next to the previous child. * @constructor * @param {Object} game - Current game instance. * @param {Object }context - The context this object is called in. */ uiWidgets.Row = function (game, context) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.game = game; this.context = context; }; uiWidgets.Row.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Row.constructor = uiWidgets.Row; /** Adds a new object into the Row, then aligns it next to the previous object. */ uiWidgets.Row.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); var previousNode = this.children[this.children.length - 2]; if (previousNode !== undefined) { node.alignTo(previousNode, Phaser.RIGHT_CENTER); } }; × Search results Close "},"scrollbar.js.html":{"id":"scrollbar.js.html","title":"Source: scrollbar.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Source: scrollbar.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Used by the scrollbar to hold the bar's values. * @constructor * @param {number} step - The amount the bar is changed by. * @param {number} minValue - The minimum value the bar can have. * @param {number} maxValue - The maximum value the bar can have. */ uiWidgets.ValueRange = function (step, minValue, maxValue) { &quot;use strict&quot;; this.step = step; this.minValue = minValue; this.maxValue = maxValue; this.ratio = step / maxValue; // The ratio between the step and max can't be greater than 1. // ie: There can't be more steps than the max value. if (this.ratio &gt; 1) { this.ratio = 1; } }; /** * Creates a bar that moves along a track. The bar is resized relative to the size of the track and size of the content to be scrolled. Content outside the viewport has input disabled. * @constructor * @param {Object} game - Current game instance. * @param {Object} content - Anything that you want to move via the scrollbar. * @param {boolean} draggable - Determines if the scrollbar responds to mouse clicks. * @param {boolean} vertical - Determines if the scrollbar should be vertical or horizontal. * @param {boolean} keyboard - Determines if the scrollbar responds to keyboard input. * @param {string} trackImage - The image key to use for the track. * @param {string} barImage - The image key to use for the bar. Will be automatically resized to fit. * @param {number} padding - Distance in pixels between the scrollbar and viewport. * @param {Object} tweenParams - Dictionary with the duration and easing function for the scrolling tween. */ uiWidgets.Scrollbar = function (game, content, draggable, vertical, keyboard, trackImage, barImage, padding, tweenParams) { &quot;use strict&quot;; this.game = game; this.content = content; this.vertical = vertical || false; this.draggable = draggable || false; keyboard = keyboard || false; if (keyboard) { this.enableKeyboard(); } this.trackImage = trackImage; this.barImage = barImage; // Padding between content and scrollbar. padding = padding || 0; if (this.vertical) { this.x = this.content.x + this.content.width + padding; this.y = this.content.y; } else { this.x = this.content.x; this.y = this.content.y + this.content.height + padding; } // The smallest pixel size allowed for the bar. this.minBarSize = 44; // Animation this.tweenParams = tweenParams || {'duration': 300, 'ease': Phaser.Easing.Quadratic.Out}; // Flag switched on when the track is clicked, switched off after the bar movement is finished. this.trackClicked = false; this.barMoving = false; // Records mouse pointer when clicking the bar. this.mousePointer = null; this.create(); }; uiWidgets.Scrollbar.prototype = { /** Enables keyboard input for the scrollbar */ enableKeyboard: function () { &quot;use strict&quot;; this.upKey = this.game.input.keyboard.addKey(Phaser.Keyboard.UP); this.downKey = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN); this.leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT); this.rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT); if (this.vertical) { this.upKey.onDown.add(this.scrollUp, this); this.downKey.onDown.add(this.scrollDown, this); this.leftKey.onDown.add(this.scrollUp, this); this.rightKey.onDown.add(this.scrollDown, this); } else { this.upKey.onDown.add(this.scrollLeft, this); this.downKey.onDown.add(this.scrollRight, this); this.leftKey.onDown.add(this.scrollLeft, this); this.rightKey.onDown.add(this.scrollRight, this); } }, /** Allows the bar to scroll when the track is clicked. */ enableTrackClick: function () { &quot;use strict&quot;; this.track.inputEnabled = true; this.track.events.onInputDown.add(this.clickTrack, this); }, create: function () { &quot;use strict&quot;; this.track = this.game.add.sprite(this.x, this.y, this.trackImage); // Clicking the track will move the bar up or down. if (this.draggable) { this.enableTrackClick(); } // Bar sprite. this.bar = this.game.add.button( this.track.x, this.track.y, this.barImage, this.moveContent, this, 1, 0 ); var verticalAttributes, horizontalAttributes; verticalAttributes = { &quot;barDefaultX&quot;: this.track.x + (this.track.width / 2) - (this.bar.width / 2), &quot;barDefaultY&quot;: this.track.y, &quot;viewportSize&quot;: this.content.area.height, &quot;containerSize&quot;: this.content.height, &quot;barMaxSize&quot;: this.track.height }; horizontalAttributes = { &quot;barDefaultX&quot;: this.track.x, &quot;barDefaultY&quot;: this.track.y + (this.track.height / 2) - (this.bar.height / 2), &quot;viewportSize&quot;: this.content.area.width, &quot;containerSize&quot;: this.content.width, &quot;barMaxSize&quot;: this.track.width }; var attributes; if (this.vertical) { attributes = verticalAttributes; } else { attributes = horizontalAttributes; } // Set default position for the bar. Center it on the non-moving axis inside the track. this.barDefaultX = attributes.barDefaultX; this.barDefaultY = attributes.barDefaultY; this.bar.x = this.barDefaultX; this.bar.y = this.barDefaultY; this.valueRange = new uiWidgets.ValueRange(attributes.viewportSize, attributes.barDefaultY, attributes.containerSize); //-- Set Bar Size --// var barSize = attributes.barMaxSize * this.valueRange.ratio; // Prevents bar from becoming microscopic. if (barSize &lt; this.minBarSize) { barSize = this.minBarSize; } // Resizes the bar. if (this.vertical) { this.bar.height = barSize; } else { this.bar.width = barSize; } //-- Enable mouse dragging on the bar. --// if (this.draggable) { this.bar.inputEnabled = true; this.bar.input.enableDrag(); this.bar.events.onInputDown.add(this.saveMousePosition, this); this.bar.events.onDragUpdate.add(this.moveContent, this); // Limit the bar's draggable area to within the track. if (this.vertical) { this.bar.input.allowHorizontalDrag = false; this.bar.input.boundsRect = new Phaser.Rectangle( this.track.x, this.track.y, this.track.x, this.track.height ); } else { this.bar.input.allowVerticalDrag = false; this.bar.input.boundsRect = new Phaser.Rectangle( this.track.x, this.track.y, this.track.width, this.track.y ); } } // Determine the distance the window can scroll over this.windowScrollAreaSize = this.valueRange.maxValue - this.valueRange.step; // Determine the distance the bar can scroll over if (this.vertical) { this.trackScrollAreaSize = this.track.height - this.bar.height; } else { this.trackScrollAreaSize = this.track.width - this.bar.width; } }, resetPosition: function () { &quot;use strict&quot;; this.bar.x = this.barDefaultX; this.bar.y = this.barDefaultY; }, /** Creates the tween for moving the bar to a new position. */ _addScrollTween: function (properties) { &quot;use strict&quot;; var newTween; newTween = this.game.add.tween(this.bar).to( properties, this.tweenParams.duration, this.tweenParams.ease, true ); this.mousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; this.trackClicked = true; newTween.onUpdateCallback(this.moveContent, this); newTween.onComplete.add(this.enableBarInput, this); }, /** For Vertical Scrollbars. Scrolls the content up by one window. */ scrollUp: function () { &quot;use strict&quot;; // Prevents users from moving the bar while it's moving. if (this.bar.y !== this.track.y &amp;&amp; !this.barMoving) { var slice = (this.track.height * this.valueRange.ratio); var testPosition = this.bar.y - slice; var moveToY = null; this.barMoving = true; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.y) { moveToY = this.track.y; } else { moveToY = this.bar.y - slice; } this._addScrollTween({y: moveToY}); } }, /** For Vertical Scrollbars. Scrolls the content down by one window. */ scrollDown: function () { &quot;use strict&quot;; if (this.bar.y + this.bar.height !== this.track.y + this.track.height &amp;&amp; !this.barMoving) { var slice = (this.track.height * this.valueRange.ratio); var testPosition = this.bar.y + (slice * 2); var moveToY = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.y + this.track.height) { moveToY = this.track.y + this.track.height - this.bar.height; } else { moveToY = this.bar.y + slice; } this._addScrollTween({y: moveToY}); } }, /** For Horizontal Scrollbars. Scrolls the content left by one window. */ scrollLeft: function () { &quot;use strict&quot;; if (this.bar.x !== this.track.x &amp;&amp; !this.barMoving) { var slice = (this.track.width * this.valueRange.ratio); var testPosition = this.bar.x - slice; var moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move above the track. if (testPosition &lt;= this.track.x) { moveToX = this.track.x; } else { moveToX = this.bar.x - slice; } this._addScrollTween({x: moveToX}); } }, /** For Horizontal Scrollbars. Scrolls the content right by one window. */ scrollRight: function () { &quot;use strict&quot;; if (this.bar.x + this.bar.width !== this.track.x + this.track.width &amp;&amp; !this.barMoving) { var slice = (this.track.width * this.valueRange.ratio); var testPosition = this.bar.x + slice * 2; var moveToX = null; this.barMoving = true; this.bar.inputEnabled = false; // Ensure the bar can't move below the track. if (testPosition &gt;= this.track.x + this.track.width) { moveToX = this.track.x + this.track.width - this.bar.width; } else { moveToX = this.bar.x + slice; } this._addScrollTween({x: moveToX}); } }, /** When called, ensures the bar can be moved. Must be called once the bar has finished scrolling. */ enableBarInput: function () { this.trackClicked = false; this.barMoving = false; this.bar.inputEnabled = true; }, /** If the scrollbar is draggable, this function is called when the track is clicked. */ clickTrack: function (sprite, pointer) { &quot;use strict&quot;; if (this.vertical) { // Don't register mouse clicks on the bar itself. if (this.game.input.mousePointer.y &gt; this.bar.y + this.bar.height) { this.scrollDown(); } else if (this.game.input.mousePointer.y &lt; this.bar.y + this.bar.height) { this.scrollUp(); } } else { // Don't register mouse clicks on the bar itself. if (this.game.input.mousePointer.x &gt; this.bar.x + this.bar.width) { this.scrollRight(); } else if (this.game.input.mousePointer.x &lt; this.bar.x + this.bar.width) { this.scrollLeft(); } } }, saveMousePosition: function (sprite, pointer) { &quot;use strict&quot;; // Record where the mouse clicked down. this.mousePointer = {&quot;x&quot;: pointer.x, &quot;y&quot;: pointer.y}; }, getBarPosition: function () { &quot;use strict&quot;; var currentArea; if (this.vertical) { // y - an offset for where the viewport is on screen. currentArea = this.content.y - this.content.area.y; } else { currentArea = this.content.x - this.content.area.x; } var windowPositionRatio = currentArea / this.windowScrollAreaSize; return this.trackScrollAreaSize * windowPositionRatio; }, /** This function is called when bar needs to move. Causes the content to move relative to the bar's position on the track. */ moveContent: function () { &quot;use strict&quot;; var gripPositionOnTrack = this.getBarPosition(); var oldMousePosition, newMousePosition, newMousePointer; if (this.vertical) { oldMousePosition = this.mousePointer.y; } else { oldMousePosition = this.mousePointer.x; } // Only difference between clicking the track/using the keyboard vs mouse drag. if (this.trackClicked) { newMousePointer = {&quot;x&quot;: this.bar.x, &quot;y&quot;: this.bar.y}; } else { newMousePointer = {&quot;x&quot;: this.game.input.mousePointer.x, &quot;y&quot;: this.game.input.mousePointer.y}; } if (this.vertical) { newMousePosition = newMousePointer.y; } else { newMousePosition = newMousePointer.x; } this.mousePointer = newMousePointer; // Maximum value for the mouse position. Only update when the new position is inside the track. var maxValue; if (this.vertical) { maxValue = this.track.height + this.track.y; } else { maxValue = this.track.width + this.track.x; } var mousePositionDelta; if (newMousePosition &lt; maxValue) { mousePositionDelta = oldMousePosition - newMousePosition; } else { mousePositionDelta = 0; } var newGripPosition = gripPositionOnTrack + mousePositionDelta; // Don't let the content scroll above or below the track's size if (newGripPosition &gt; 0) { newGripPosition = 0; } else if (newGripPosition &lt;= -this.trackScrollAreaSize) { newGripPosition = -this.trackScrollAreaSize; } // When the scrollbar is at the top or bottom, prevent a mouse movement that // doesn't move the scrollbar from moving the content. if (this.vertical) { if (this.bar.y &lt;= this.track.y) { newGripPosition = 0; } else if (this.bar.y + this.bar.height &gt;= this.track.y + this.track.height) { newGripPosition = -this.trackScrollAreaSize; } } else { if (this.bar.x &lt;= this.track.x) { newGripPosition = 0; } else if (this.bar.x + this.bar.width &gt;= this.track.x + this.track.width) { newGripPosition = -this.trackScrollAreaSize; } } var newGripPositionRatio = newGripPosition / this.trackScrollAreaSize; // If the scrollable area is less than the size of the scrollbar, the bar and track will be the same size. // In this scenario, a divide by zero occurs. Capture that and turn it into zero. if (isNaN(newGripPositionRatio)) { newGripPositionRatio = 0; } var newContentPosition = newGripPositionRatio * this.windowScrollAreaSize; // Set the content's new position. Uses an offset for where the viewport is on screen. if (this.vertical) { this.content.y = newContentPosition + this.content.area.y; } else { this.content.x = newContentPosition + this.content.area.x; } this.content.disableOutOfBounds(this.content.children, this, this.vertical); } }; × Search results Close "},"buttons.js.html":{"id":"buttons.js.html","title":"Source: buttons.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Source: buttons.js var Phaser; var uiWidgets = uiWidgets || {}; /** * Sprite with text added as a child. * @constructor * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. */ uiWidgets.textSprite = function (game, image, label, style, x, y) { &quot;use strict&quot;; Phaser.Sprite.call(this, game, x, y, image); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); }; uiWidgets.textSprite.prototype = Object.create(Phaser.Sprite.prototype); uiWidgets.textSprite.constructor = uiWidgets.textSprite; /** * Phaser Button with text added as a child. * @constructor * @param {Object} game - Current game instance. * @param {string} image - The image to create a sprite with. * @param {string} label - The text to place on top of the sprite. * @param {Object} style - The style properties to be set on the Text. * @param {number} x - The x coordinate on screen where the textSprite will be placed. * @param {number} y - The y coordinate on screen where the textSprite will be placed. * @param callback - Callback to use when the button is clicked. * @param callbackContext {Object} - The context the callback is called in. */ uiWidgets.textButton = function (game, image, label, style, x, y, callback, callbackContext) { &quot;use strict&quot;; Phaser.Button.call(this, game, x, y, image, callback, callbackContext); game.add.existing(this); this.text = this.game.add.text(0, 0, label, style); this.text.anchor.set(0.5, 0.5); this.addChild(this.text); }; uiWidgets.textButton.prototype = Object.create(Phaser.Button.prototype); uiWidgets.textButton.constructor = uiWidgets.textButton; × Search results Close "},"viewport.js.html":{"id":"viewport.js.html","title":"Source: viewport.js","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Source: viewport.js var Phaser; var uiWidgets = uiWidgets || {}; /** * A container for other objects with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area. * @constructor * @param {Object} game - Current game instance. * @param {number} x - The x coordinate on screen where the viewport will be placed. * @param {number} y - The y coordinate on screen where the viewport will be placed. * @param width {number} - The width of the viewport. * @param height {number} - The height of the viewport. */ uiWidgets.Viewport = function (game, x, y, width, height) { &quot;use strict&quot;; Phaser.Group.call(this, game); game.add.existing(this); this.x = x; this.y = y; // Viewport size and position, distinct from the total window size. this.area = { &quot;x&quot;: x, &quot;y&quot;: y, &quot;width&quot;: width, &quot;height&quot;: height }; // Adding the mask attribute to a group hides objects outside the mask. this.mask = this.game.add.graphics(this.area.x, this.area.y); this.mask.beginFill(0x0000ff); this.mask.drawRect(0, 0, width, height); this.mask.endFill(); }; uiWidgets.Viewport.prototype = Object.create(Phaser.Group.prototype); uiWidgets.Viewport.constructor = uiWidgets.Viewport; /** Adds a new object into the Viewport. */ uiWidgets.Viewport.prototype.addNode = function (node) { &quot;use strict&quot;; this.add(node); }; /** Disable input for all objets outside the viewport's visible area. */ uiWidgets.Viewport.prototype.disableOutOfBounds = function (children, context, vertical) { &quot;use strict&quot;; var child, location, contentLocation, trueCoords; // Makes sure the recursive function stops when there's no children. if (children !== undefined) { for (var i = 0; i &lt; children.length; i++) { child = children[i]; child.inputEnabled = true; // An object's x/y is relative to it's parent. // The world gives an x/y relative to the whole game. trueCoords = child.world || child; if (vertical) { location = trueCoords.y; contentLocation = context.content.area.y; } else { location = trueCoords.x; contentLocation = context.content.area.x; } if (location &lt; contentLocation) { child.inputEnabled = false; } this.disableOutOfBounds(child.children, context, vertical); } } }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Classes Classes Column Row Scrollbar textButton textSprite ValueRange Viewport × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport × Search results Close "},"uiWidgets.Column.html":{"id":"uiWidgets.Column.html","title":"Class: Column","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: Column Column new Column(game, context) Group that places new child nodes directly under the previous child. Parameters: Name Type Description game Object Current game instance. context Object The context this object is called in. Source: column.js, line 11 Methods addNode() Adds a new object into the Column, then aligns it under the previous object. Source: column.js, line 25 × Search results Close "},"uiWidgets.Row.html":{"id":"uiWidgets.Row.html","title":"Class: Row","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: Row Row new Row(game, context) Group that places new child nodes directly next to the previous child. Parameters: Name Type Description game Object Current game instance. context Object The context this object is called in. Source: row.js, line 11 Methods addNode() Adds a new object into the Row, then aligns it next to the previous object. Source: row.js, line 25 × Search results Close "},"uiWidgets.Scrollbar.html":{"id":"uiWidgets.Scrollbar.html","title":"Class: Scrollbar","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: Scrollbar Scrollbar new Scrollbar(game, content, draggable, vertical, keyboard, trackImage, barImage, padding, tweenParams) Creates a bar that moves along a track. The bar is resized relative to the size of the track and size of the content to be scrolled. Content outside the viewport has input disabled. Parameters: Name Type Description game Object Current game instance. content Object Anything that you want to move via the scrollbar. draggable boolean Determines if the scrollbar responds to mouse clicks. vertical boolean Determines if the scrollbar should be vertical or horizontal. keyboard boolean Determines if the scrollbar responds to keyboard input. trackImage string The image key to use for the track. barImage string The image key to use for the bar. Will be automatically resized to fit. padding number Distance in pixels between the scrollbar and viewport. tweenParams Object Dictionary with the duration and easing function for the scrolling tween. Source: scrollbar.js, line 40 Methods _addScrollTween() Creates the tween for moving the bar to a new position. Source: scrollbar.js, line 225 clickTrack() If the scrollbar is draggable, this function is called when the track is clicked. Source: scrollbar.js, line 333 enableBarInput() When called, ensures the bar can be moved. Must be called once the bar has finished scrolling. Source: scrollbar.js, line 326 enableKeyboard() Enables keyboard input for the scrollbar Source: scrollbar.js, line 85 enableTrackClick() Allows the bar to scroll when the track is clicked. Source: scrollbar.js, line 106 moveContent() This function is called when bar needs to move. Causes the content to move relative to the bar's position on the track. Source: scrollbar.js, line 374 scrollDown() For Vertical Scrollbars. Scrolls the content down by one window. Source: scrollbar.js, line 263 scrollLeft() For Horizontal Scrollbars. Scrolls the content left by one window. Source: scrollbar.js, line 283 scrollRight() For Horizontal Scrollbars. Scrolls the content right by one window. Source: scrollbar.js, line 304 scrollUp() For Vertical Scrollbars. Scrolls the content up by one window. Source: scrollbar.js, line 242 × Search results Close "},"uiWidgets.textButton.html":{"id":"uiWidgets.textButton.html","title":"Class: textButton","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: textButton textButton new textButton(game, image, label, style, x, y, callback, callbackContext) Phaser Button with text added as a child. Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. callback Callback to use when the button is clicked. callbackContext Object The context the callback is called in. Source: buttons.js, line 43 × Search results Close "},"uiWidgets.textSprite.html":{"id":"uiWidgets.textSprite.html","title":"Class: textSprite","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: textSprite textSprite new textSprite(game, image, label, style, x, y) Sprite with text added as a child. Parameters: Name Type Description game Object Current game instance. image string The image to create a sprite with. label string The text to place on top of the sprite. style Object The style properties to be set on the Text. x number The x coordinate on screen where the textSprite will be placed. y number The y coordinate on screen where the textSprite will be placed. Source: buttons.js, line 16 × Search results Close "},"uiWidgets.ValueRange.html":{"id":"uiWidgets.ValueRange.html","title":"Class: ValueRange","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: ValueRange ValueRange new ValueRange(step, minValue, maxValue) Used by the scrollbar to hold the bar's values. Parameters: Name Type Description step number The amount the bar is changed by. minValue number The minimum value the bar can have. maxValue number The maximum value the bar can have. Source: scrollbar.js, line 12 × Search results Close "},"uiWidgets.Viewport.html":{"id":"uiWidgets.Viewport.html","title":"Class: Viewport","body":" DocStrap Classes uiWidgets.ColumnuiWidgets.RowuiWidgets.ScrollbaruiWidgets.textButtonuiWidgets.textSpriteuiWidgets.ValueRangeuiWidgets.Viewport Class: Viewport Viewport new Viewport(game, x, y, width, height) A container for other objects with a limited viewable area. Uses a mask to hide children outside of the specified x/y/width/height area. Parameters: Name Type Description game Object Current game instance. x number The x coordinate on screen where the viewport will be placed. y number The y coordinate on screen where the viewport will be placed. width number The width of the viewport. height number The height of the viewport. Source: viewport.js, line 15 Methods addNode() Adds a new object into the Viewport. Source: viewport.js, line 42 disableOutOfBounds() Disable input for all objets outside the viewport's visible area. Source: viewport.js, line 49 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
